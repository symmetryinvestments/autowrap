/**
   Functions to wrap entities in D modules for Python consumption.

   These functions are usually not called directly, but from the mixin generated by
   autowrap.python.boilerplate.pydBoilerplate.
 */
module autowrap.python.wrap;

import autowrap.types: isModule;
import autowrap.reflection: isUserAggregate;
import std.meta: allSatisfy;
import std.traits: isArray;


private alias I(alias T) = T;
private enum isString(alias T) = is(typeof(T) == string);

///  Wrap global functions from multiple modules
void wrapAllFunctions(Modules...)() if(allSatisfy!(isModule, Modules)) {
    import autowrap.common: toSnakeCase, AlwaysTry;
    import autowrap.reflection: AllFunctions;
    import pyd.pyd: def, PyName;

    static foreach(function_; AllFunctions!Modules) {
        static if(AlwaysTry || __traits(compiles, def!(function_.symbol, PyName!(toSnakeCase(function_.identifier)))()))
            def!(function_.symbol, PyName!(toSnakeCase(function_.identifier)))();
        else {
            pragma(msg, "\nERROR! Autowrap could not wrap function `", function_.identifier, "` for Python\n");
            // def!(function_.symbol, PyName!(toSnakeCase(function_.identifier)))();
        }
    }
}


/**
   wrap all aggregates found in the given modules, specified by their name
   (to avoid importing all of them first).

   This function wraps all struct and class definitions, and also all struct and class
   types that are parameters or return types of any functions found.
 */
void wrapAllAggregates(Modules...)() if(allSatisfy!(isModule, Modules)) {

    import autowrap.common: AlwaysTry;
    import autowrap.reflection: AllAggregates;
    import std.traits: fullyQualifiedName;

    static foreach(aggregate; AllAggregates!Modules) {
        static if(is(T == enum)) {
            pragma(msg, "WARNING! Could not wrap `", fullyQualifiedName!aggregate, "` since pyd doesn't support enums");
        } else {
            static if(AlwaysTry || __traits(compiles, wrapAggregate!aggregate))
                wrapAggregate!aggregate;
            else {
                pragma(msg, "\nERROR! Autowrap could not wrap aggregate `", fullyQualifiedName!aggregate, "` for Python\n");
                //wrapAggregate!aggregate; // uncomment to see the error messages from the compiler
            }
        }
    }
}


/**
   Wrap aggregate of type T.
 */
auto wrapAggregate(T)() if(isUserAggregate!T) {

    import autowrap.python.pyd.class_wrap: MemberFunction;
    import mirror.meta.traits: isProperty, isStaticMemberFunction, PublicFieldNames;
    import pyd.pyd: wrap_class, Member, Init, StaticDef, Repr, Property;
    import std.meta: staticMap, Filter, templateNot, AliasSeq;
    import std.algorithm: startsWith;
    import std.traits : isAbstractFunction;

    alias AggMember(string memberName) = Symbol!(T, memberName);
    alias members = staticMap!(AggMember, __traits(allMembers, T));
    alias memberFunctions = Filter!(isMemberFunction, members);
    alias staticMemberFunctions = Filter!(isStaticMemberFunction, memberFunctions);
    alias nonStaticMemberFunctions = Filter!(templateNot!isStaticMemberFunction, memberFunctions);
    enum isOperator(alias F) = __traits(identifier, F).startsWith("op");
    alias regularMemberFunctions =
        Filter!(templateNot!isOperator,
                Filter!(templateNot!isAbstractFunction,
                        Filter!(templateNot!isProperty,
                                nonStaticMemberFunctions)));
    alias properties = Filter!(isProperty, nonStaticMemberFunctions);
    alias publicFieldNames = PublicFieldNames!T;

    enum isToString(alias F) = __traits(identifier, F) == "toString";

    wrap_class!(
        T,
        staticMap!(Member, publicFieldNames),
        staticMap!(MemberFunction, regularMemberFunctions),
        staticMap!(StaticDef, staticMemberFunctions),
        staticMap!(InitTuple, ConstructorParamTuples!T),
        staticMap!(Repr, Filter!(isToString, memberFunctions)),
        staticMap!(Property, properties),
        OpUnaries!T,
        OpBinaries!T,
        OpBinaryRights!T,
        OpCmps!T,
        Lengths!T,
        OpIndices!T,
        DefOpSlices!T,
        OpSliceRanges!T,
        OpOpAssigns!T,
        OpIndexAssigns!T,
        OpSliceAssigns!T,
        OpCalls!T,
   );
}


// Given a parent (module, struct, ...) and a memberName, alias the actual member,
// or void if not possible
private template Symbol(alias parent, string memberName) {
    static if(__traits(compiles, I!(__traits(getMember, parent, memberName))))
        alias Symbol = I!(__traits(getMember, parent, memberName));
    else
        alias Symbol = void;
}


private template DefOpSlices(T) {
    import std.traits: hasMember, Parameters;
    import std.meta: AliasSeq, Filter, staticMap;

    static if(hasMember!(T, "opSlice")) {
        // See testdll for details on this
        enum hasNoParams(alias F) = Parameters!F.length == 0;
        alias iters = Filter!(hasNoParams, __traits(getOverloads, T, "opSlice"));
        alias defIters = staticMap!(DefOpSlice, iters);

        alias DefOpSlices = AliasSeq!(defIters);
    } else
        alias DefOpSlices = AliasSeq!();
}

private template DefOpSlice(alias F) {
    import pyd.pyd: Def, PyName;
    import std.traits: ReturnType, Parameters;
    alias DefOpSlice = Def!(F, PyName!"__iter__", ReturnType!F function(Parameters!F));
}

private template OpSliceRanges(T) {
    import pyd.pyd: OpSlice;
    import std.traits: hasMember, Parameters, isIntegral;
    import std.meta: AliasSeq, Filter, allSatisfy, staticMap;

    static if(hasMember!(T, "opSlice")) {
        enum hasTwoIntParams(alias F) =
            allSatisfy!(isIntegral, Parameters!F) && Parameters!F.length == 2;
        alias twoInts = Filter!(hasTwoIntParams, __traits(getOverloads, T, "opSlice"));

        static if(twoInts.length > 0) {
            // pyd is very specific about this for some reason
            static if(__traits(compiles, OpSlice!().Inner!T))
                alias OpSliceRanges =  OpSlice!();
            else
                alias OpSliceRanges = AliasSeq!();
        } else
            alias OpSliceRanges = AliasSeq!();
    } else
        alias OpSliceRanges = AliasSeq!();
}



// A tuple, with as many elements as constructors. Each element is a
// std.typecons.Tuple of the constructor parameter types.
private template ConstructorParamTuples(alias T) {
    import std.meta: staticMap, AliasSeq;
    import std.traits: Parameters, hasMember;
    import std.typecons: Tuple;

    // If we staticMap with std.traits.Parameters, we end up with a collapsed tuple
    // i.e. with one constructor that takes int and another that takes int, string,
    // we'd end up with 3 elements (int, int, string) instead of 2 ((int), (int, string))
    // so we package them up in a std.typecons.Tuple to avoid flattening
    // each being an AliasSeq of types for the constructor
    alias ParametersTuple(alias F) = Tuple!(Parameters!F);

    static if(hasMember!(T, "__ctor"))
        alias constructors = AliasSeq!(__traits(getOverloads, T, "__ctor"));
    else
        alias constructors = AliasSeq!();

    // A tuple, with as many elements as constructors. Each element is a
    // std.typecons.Tuple of the constructor parameter types.
    alias ConstructorParamTuples = staticMap!(ParametersTuple, constructors);
}

// Apply pyd's Init to the unpacked types of the parameter Tuple.
private template InitTuple(alias Tuple) {
    import pyd.pyd: Init;
    alias InitTuple = Init!(Tuple.Types);
}


private alias OpBinaries(T)     = Operators!(T, "opBinary");
private alias OpBinaryRights(T) = Operators!(T, "opBinaryRight");
private alias OpUnaries(T)      = Operators!(T, "opUnary");
private alias OpOpAssigns(T)    = Operators!(T, "opOpAssign");

private template Operators(T, string name) {
    import std.uni: toUpper;
    import std.conv: text;

    private enum pascalName = name[0].toUpper.text ~ name[1..$];
    static if(pascalName == "OpOpAssign")
        private enum pydName = "OpAssign";
    else
        private enum pydName = pascalName;

    mixin(`import pyd.pyd: ` ~ pydName ~ `;`);
    import std.meta: AliasSeq, staticMap, Filter;
    import std.traits: hasMember;

    private enum hasOperator(string op) = is(typeof(probeTemplate!(T, name, op)));
    mixin(`alias toPyd(string op) = ` ~ pydName ~ `!op;`);

    alias pythonableOperators = AliasSeq!(
        "+", "-", "*", "/", "%", "^^", "<<", ">>", "&", "^", "|", "in", "~",
    );

    static if(hasMember!(T, name)) {
        private alias dOperatorNames = Filter!(hasOperator, pythonableOperators);
        alias Operators = staticMap!(toPyd, dOperatorNames);
    } else
        alias Operators = AliasSeq!();
}


private auto probeTemplate(T, string templateName, string op)() {
    import std.traits: ReturnType, Parameters;
    import std.meta: Alias;

    mixin(`alias func = T.` ~ templateName ~ `;`);
    alias R = ReturnType!(func!op);
    alias P = Parameters!(func!op);

    auto obj = T.init;

    static if(is(R == void))
        mixin(`obj.` ~ templateName ~ `!op(P.init);`);
    else
        mixin(`R ret = obj.` ~ templateName ~ `!op(P.init);`);
}


private template OpCmps(T) {
    import pyd.pyd: OpCompare;
    import std.traits: hasMember;
    import std.meta: AliasSeq;

    static if(hasMember!(T, "opCmp")) {
        static if(__traits(compiles, OpCompare!().Inner!T))
            alias OpCmps = AliasSeq!(OpCompare!());
        else
            alias OpCmps = AliasSeq!();
    } else
        alias OpCmps = AliasSeq!();
}

private template Lengths(T) {
    import pyd.pyd: Len;
    import std.meta: AliasSeq;

    static if(is(typeof(T.init.length)))
        alias Lengths = Len!(T.length);
    else
        alias Lengths = AliasSeq!();
}

private template OpIndices(T) {
    import pyd.pyd: OpIndex;
    import std.meta: AliasSeq;

    static if(is(typeof(T.init.opIndex(0))))
        alias OpIndices = OpIndex!();
    else
        alias OpIndices = AliasSeq!();
}


private template OpIndexAssigns(T) {
    import pyd.pyd: OpIndexAssign;
    import std.meta: AliasSeq;
    import std.traits: hasMember;

    static if(hasMember!(T, "opIndexAssign")) {
        static if(__traits(compiles, OpIndexAssign!().Inner!T))
            alias OpIndexAssigns = OpIndexAssign!();
        else
            alias OpIndexAssigns = AliasSeq!();
    } else
        alias OpIndexAssigns = AliasSeq!();
}


private template OpSliceAssigns(T) {
    import pyd.pyd: OpSliceAssign;
    import std.meta: AliasSeq;
    import std.traits: hasMember;

    static if(hasMember!(T, "opSliceAssign")) {
        static if(__traits(compiles, OpSliceAssign!().Inner!T))
            alias OpSliceAssigns = OpSliceAssign!();
        else
            alias OpSliceAssigns = AliasSeq!();
    } else
        alias OpSliceAssigns = AliasSeq!();
}


private template OpCalls(T) {
    import pyd.pyd: OpCall;
    import std.meta: AliasSeq, staticMap;
    import std.traits: hasMember, Parameters;

    static if(hasMember!(T, "opCall")) {
        alias overloads = AliasSeq!(__traits(getOverloads, T, "opCall"));
        alias opCall(alias F) = OpCall!(Parameters!F);
        alias OpCalls = staticMap!(opCall, overloads);
    } else
        alias OpCalls = AliasSeq!();
}


// must be a global template
private template isMemberFunction(A...) if(A.length == 1) {
    import std.algorithm: startsWith;

    alias T = A[0];

    static if(__traits(compiles, __traits(identifier, T))) {
        enum name = __traits(identifier, T);
        enum isMemberFunction =
            isPublicFunction!T
            && !name.startsWith("__")
            && name != "toHash"
            ;
    } else
        enum isMemberFunction = false;
}


private template isPublicFunction(alias F) {
    import std.traits: isFunction;
    enum prot = __traits(getProtection, F);
    enum isPublicFunction = isFunction!F && (prot == "export" || prot == "public");
}
